#!/usr/bin/env python3
# coding=utf-8
"""
@author: f.l
@time: 2022/5/11
@File: one_more_01.py
补充：

`__slot__`:
    槽位，槽位数有限。
    字典为了提升查询效率，必须用空间换时间。
    一般来说一个对象，属性多一点，都存储在字典中便于查询，问题不大。
    假设有一百万个实例，这些实例的属性都放在字典中，消耗内存很大，这个时候怎么办，使用`__slot__`，把属性字典`__dict__`省了，使用`__slot__`规定对象有什么属性。

    小结：
        - 定义了__slots__后，它限定了实例的属性，同时阻止实例产生__dict__, 把__dict__消灭掉。
        - 预测到为了，某个对象可能产生大量的实例，且这个实例有很多不会用到的属性，这个时候就可以用__slot__来暴露需要的属性，节省内存。
        - 给出了__slot__后，就无法动态增加属性了。
        - `__slot__`不影响继承，父类给出了`__slot__`，在子类中不生效，如果子类需要，必须重新定义。

**应用场景：** 需要构造上百万给实例，内存紧张
"""


class A:
    X = 123
    #  定义了__slots__后，它限定了实例的属性，同时阻止实例产生__dict__, 把__dict__消灭掉。
    #  预测未来某个对象可能产生大量的实例，且这个实例有很多不会用到的属性，这个时候就可以用__slot__来暴露需要的属性，节省内存。
    #  给出了__slot__后，就无法动态增加属性了。
    __slots__ = 'p1'  # , 'p2'  #  可以是列表、元组，里面放得是字符串名称。但是既然考虑节约内存了，用元组比较好

    def __init__(self):
        self.p1 = 1
        # self.p2 = 2
        pass

    def showme(self):
        print('I am A. {}'.format(self.p1))


class B(A):
    pass


if __name__ == '__main__':
    print(A.__dict__)
    # print(A().__dict__)
    a = A()
    print(a.__slots__)
    a.showme()
    # a.p3 = 120  # 给出了__slot__后，就无法动态增加属性了。
    print(a.X)
    # a.X = 1  # 可以吗？赋值即定义，实例不能改变类的属性，是给实例增加属性，所以肯定不可以
    print(B().__dict__)
